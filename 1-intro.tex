\section{总体设计}

\subsection{背景与动机}
传统命令式语言（C、Java、Python 等）以赋值为核心，
一旦语句执行完毕，变量之间的语义关系就被切断；
当上游数据变化时，下游值不会自动保持一致。
随着 UI 状态管理、IoT 数据流、实时监控等场景的复杂化，
开发者不得不在回调、订阅和手动更新的迷宫中穿梭，
既容易出现故障，又充满样板代码。

随着现代软件对实时性要求的提高
（如高频交易、即时大盘、复杂的前端交互），
这种"手动同步状态"的开发模式导致了大量的冗余代码和难以维护的回调困境。

现有的响应式库（如 RxJS）提供了补丁式的 API，
但需要工程师自己拼接依赖图、处理订阅生命周期，
无法在编译期验证拓扑是否安全，也缺乏"计算一次即稳定"的强保证。
Ripple 的诞生正是为了解决这一同步危机：
让"变量就是流"成为语言级别的内建语义，
把依赖图视为运行时的一等公民，
用编译期检查和拓扑驱动的执行模型消除中间错误状态。

\subsection{设计目标与核心特性}
\begin{itemize}
  \item \textbf{原生响应式：}
        以 \verb|source|/\verb|stream|/\verb|sink| 三类节点表达依赖关系，
        使用 \verb|<-| 建立持久绑定，避免显式订阅或手动更新。
  \item \textbf{零故障传播：}
        编译期预计算依赖、运行时按拓扑高度调度，
        保证每次输入事件中每个节点最多计算一次，外部永远看到一致状态。
  \item \textbf{静态类型与流类型：}
        基础类型（\verb|int|, \verb|float|, \verb|bool|, \verb|string|）
        与 \verb|Stream<T>| 组合，
        声明式的类型注解有助于早期发现类型与引用错误。
  \item \textbf{声明式语法：}
        类似电子表格的"所见即所得"写法（如 \verb|stream D <- B + C;|），
        强调表达式而非执行顺序。
  \item \textbf{内建时间语义：}
        提供 \verb|pre|（历史值）与 \verb|fold|（状态累积）这样的时序原语，
        无需外部库即可编写有状态流。
  \item \textbf{严格错误检测：}
        编译阶段即捕获循环依赖、未定义引用、重复定义等问题，
        遵循"早失败"原则，避免故障流入运行时。
  \item \textbf{高性能图引擎：}
        运行时采用图归约引擎和基于高度的优先队列，
        兼顾稳定性与事件传播性能，为后续并行和内存局部性优化奠定基础。
\end{itemize}

\subsection{参考与借鉴}
Ripple 的语法与运行时设计参考了多种成熟语言的范式：
\begin{itemize}
  \item \textbf{电子表格模型（Excel）：}
        单元格间的持久依赖关系启发了"变量即流"的核心语义。
  \item \textbf{函数式响应式编程（Elm/RxJS）：}
        事件流与组合子的思想影响了 \verb|stream| 节点与流式表达式设计，
        但 Ripple 将其下沉到语言与编译器层，并提供拓扑级的安全保证。
  \item \textbf{强类型语言家族（ML/Rust/TypeScript）：}
        使用显式类型标注（\verb|name : type|）
        和 \verb|if ... then ... else ...| 风格的表达式语法，
        使流计算同时保持可读性与可验证性。
  \item \textbf{同步数据流语言（Lustre 等）：}
        时序原语 \verb|pre| 与 \verb|fold| 借鉴了同步流语言的时间抽象，
        使状态演化自然地融入依赖图。
\end{itemize}
