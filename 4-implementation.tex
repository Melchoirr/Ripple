%======================  以下為正文 ======================
\section{系统实现}
本章从工程视角给出"设计 $\rightarrow$ 代码"的完整映射：
前端如何产出带类型的 AST，编译器如何生成运行时依赖图，
运行时如何在事件驱动下保持一致性，
以及类型系统、内存管理、对象模型等核心机制的落地细节。
所有描述均可在仓库源文件中找到对应实现与注释。

\subsection{架构与流水线概览}
\paragraph{总体分层}
Ripple 采用"前端（词法/语法/AST）—类型/检查—代码生成—运行时图引擎"流水线：
\begin{enumerate}
  \item \textbf{词法}（\texttt{ripple\_lexer.py}）：
        手写状态机扫描字符流，产出带行列号的 Token 流。
  \item \textbf{语法}（\texttt{ripple\_parser.py}）：
        递归下降解析 Token，按 EBNF 生成 AST；
        解析时提前计算静态依赖与状态性标记。
  \item \textbf{类型检查}（\texttt{ripple\_typechecker.py}）：
        TypeVisitor 风格的分派，对声明和表达式做类型推断/兼容性检查，
        生成类型环境。
  \item \textbf{代码生成}（\texttt{ripple\_compiler.py}）：
        非传统字节码后端，而是把 AST 降解为"依赖图 + 可执行公式"：
        为每个节点构造 Python 可调用的公式，填入图引擎。
  \item \textbf{运行时}（\texttt{ripple\_engine.py}）：
        基于拓扑 rank 的图执行器，
        维护节点状态、事件队列与订阅关系，按触发器增量求值。
\end{enumerate}
该流程由 \texttt{ripple\_runner.py} 驱动：读取源码，Lexer/Parser 构建 AST，
TypeChecker 完成检查，Compiler 构建图，Engine 在事件到达时执行。

\paragraph{数据流与元信息}
核心数据形态依次为：
字符流 $\rightarrow$ Token 流 $\rightarrow$
AST（携带 \texttt{static\_dependencies}、\texttt{is\_stateful} 等标记）$\rightarrow$
运行时 GraphNode（含 rank、依赖、触发器、状态槽）$\rightarrow$
事件帧中的上下文/堆。

\subsection{前端实现细节}
\paragraph{词法器：最小回溯的手写状态机}
\texttt{RippleLexer} 以单次线性扫描产出 Token，关键点：
\begin{itemize}
  \item 关键字表与运算符最长匹配
        （优先识别 \texttt{<-}、\texttt{:=}、\texttt{~>}、\texttt{==} 等多字符操作符）。
  \item 数字/字符串字面量与布尔值都带静态类型标签，便于后续类型推断。
  \item 行列号在换行时维护，为错误报告和源映射提供基础。
  \item 注释/空白跳过，不生成 Token，确保语法无歧义。
\end{itemize}

\paragraph{语法器：递归下降与优先级表}
\texttt{RippleParser} 采用纯手写递归下降：
\begin{itemize}
  \item 按优先级链条拆分
        （逻辑 $\rightarrow$ 比较 $\rightarrow$ 加减 $\rightarrow$ 乘除
        $\rightarrow$ 一元 $\rightarrow$ 后缀），避免回溯。
  \item 在解析 \texttt{StreamDecl} 时调用 \texttt{extract\_dependencies}、
        \texttt{is\_stateful\_expr}，提前标记依赖集合和是否含 \texttt{pre}/\texttt{fold}。
  \item 触发器 \texttt{on pos.x} 允许字段链，
        解析时拼接成完整字段路径，供运行时订阅过滤使用。
  \item 错误恢复通过哨兵 Token/异常抛出实现，交由上层汇总。
\end{itemize}

\paragraph{AST 结构：与运行时对齐}
\texttt{ripple\_ast.py} 定义的节点与运行时需求直连：
\begin{itemize}
  \item \textbf{类型族}：\texttt{BasicType}、\texttt{StreamType}、
        \texttt{ArrayType}、\texttt{StructType}、\texttt{FunctionType}，
        支持结构体字段映射。
  \item \textbf{表达式族}：覆盖算子、Lambda、数组/结构体、
        map/filter/reduce、pre/fold 等响应式/高阶原语。
  \item \textbf{声明族}：\texttt{SourceDecl}/\texttt{StreamDecl}/\texttt{SinkDecl}
        携带 \texttt{rank}、\texttt{static\_dependencies}、\texttt{is\_stateful}，
        为编译器与引擎直接复用。
\end{itemize}

\subsection{类型系统：推断与检查的落地}
\paragraph{两遍策略与环境}
\texttt{TypeChecker.check\_program} 先收集类型别名与函数签名，
再对源/流/sink 扫描推断表达式类型，维护：
\begin{itemize}
  \item 类型环境 \texttt{type\_env}：变量/字段 $\mapsto$ 类型。
  \item 类型别名 \texttt{type\_aliases}：
        \texttt{type Point = \{x:int,y:int\}} 等结构体别名。
  \item 用户函数 \texttt{user\_functions}：
        记录参数名列表与函数体，供调用时检查。
  \item 内置函数签名表：\texttt{abs}/\texttt{sqrt}/\texttt{max}/\texttt{min}、
        数组函数 \texttt{len}/\texttt{head}/\texttt{tail}/\texttt{last}/
        \texttt{sum}/\texttt{reverse}/\texttt{transpose}、\texttt{load\_csv} 等，
        使用形参约束（number/array/element）与返回类型。
\end{itemize}

\paragraph{表达式分派与约束}
\texttt{infer\_expression} 按节点类型分派：
\begin{itemize}
  \item 字面量/标识符直接返回对应类型或环境查找。
  \item 算子检查：算术/比较要求数字或可比较类型，不符则记录错误；
        逻辑操作要求布尔。
  \item if/let 维持分支/局部环境；数组字面量统一元素类型；
        字段访问在结构体类型中查找。
  \item map/filter/reduce/fold 等高阶操作对 Lambda 形参、
        数组元素类型生成约束，fold 初值与累加器类型需兼容。
  \item Lambda 在缺乏上下文时降为 \texttt{BasicType('any')} 以避免阻塞推断。
\end{itemize}

\paragraph{错误模型与报告}
类型不兼容、未注解且不可推断的源、字段不存在等会被收集为 \texttt{TypeError} 列表，
由编译器打印警告；类型信息仍写回环境供后端使用。
编译器还会补全结构体字段到 \texttt{type\_env}（如 \texttt{pos.x}），
以便触发器/依赖检查。

\subsection{代码生成：依赖图而非字节码}
\paragraph{总体取舍}
Ripple 不生成自定义字节码或 LLVM IR，而是直接将 AST 降解为运行时"图 + 公式"：
\begin{itemize}
  \item \textbf{公式生成}：\texttt{ExpressionEvaluator} 充当解释器，
        支持所有表达式节点（含 pre/fold、数组高阶、结构体字段），
        \texttt{RippleCompiler} 为每个流/sink 构造闭包
        \texttt{lambda ctx: evaluate(expr, ctx)}。
  \item \textbf{依赖/触发元数据}：静态依赖集合、触发器字段链、
        stateful 标记在编译期附着到节点，运行时直接使用。
  \item \textbf{常量与初值}：源的初值在编译期求值
        （必要时调用 \texttt{load\_csv}），填入运行时存储；
        结构体字段展开为虚拟源，便于字段级订阅。
\end{itemize}

\paragraph{编译步骤（对应 \texttt{RippleCompiler.compile}）}
\begin{enumerate}
  \item \textbf{类型/函数登记}：先处理 \texttt{type} 与 \texttt{func} 声明，
        填充 \texttt{type\_defs} 与 \texttt{user\_functions}，并交给表达式求值器。
  \item \textbf{类型检查}：运行 TypeChecker，打印推断结果（供调试），
        若有类型错误先告警。
  \item \textbf{重复/未定义/循环检测}：调用 \texttt{DuplicateDefinitionChecker}、
        \texttt{UndefinedReferenceChecker}、\texttt{CircularDependencyDetector}
        生成错误报告，阻断编译。
  \item \textbf{源编译}：求值初始表达式，注册 CSV 源（文件路径、跳表头标志），
        在 Engine 中创建源节点。
  \item \textbf{rank 计算与流编译}：依据依赖图计算拓扑高度；
        按 rank 顺序为每个流注册公式与订阅关系
        （触发器决定哪些依赖会触发重算）。
  \item \textbf{Sink 编译与初始化传播}：Sink 视作无下游的流；
        最后触发一次初始化传播，使所有节点缓存一致值。
\end{enumerate}

\subsection{运行时与调度：栈式求值 + 图传播}
\paragraph{GraphNode 布局}
\texttt{GraphNode} 是运行时核心结构：\texttt{name}、\texttt{formula}（Python 函数）、
\texttt{cached\_value}、\texttt{rank}、\texttt{is\_stateful}、\texttt{state}（用于 pre/fold）、
\texttt{dependencies}、\texttt{subscribers}、\texttt{is\_source}、\texttt{is\_dirty}。
相比传统 VM 对象头，它直接携带拓扑与状态元数据。

\paragraph{事件循环与优先队列}
\texttt{RippleEngine} 维护小顶堆 \texttt{priority\_queue}
（\texttt{PriorityQueueItem(rank,name)}）：
\begin{itemize}
  \item \textbf{推送事件}：\texttt{push\_event} 更新源节点的 \texttt{cached\_value}，
        标记脏并将其订阅者入队。
  \item \textbf{propagate}：每次取出 rank 最小的节点，检查触发依赖是否脏；
        满足则执行公式求值，更新缓存与 state，通知下游；否则跳过。
  \item \textbf{stateful 节点}：pre 使用 \texttt{state} 存上一时刻值，
        fold 的累加器同样驻留在 \texttt{state}，保证时间一致性。
\end{itemize}

\paragraph{表达式求值器：解释执行}
\texttt{ExpressionEvaluator.evaluate} 以上下文字典为环境，递归解释 AST，支持：
\begin{itemize}
  \item 算子、条件、let、Lambda 与函数调用（用户函数或内置）。
  \item map/filter/reduce/fold 的高阶求值，使用扩展上下文绑定形参。
  \item 结构体字段访问支持"短路路径"：
        若上下文已有完整字段名（如 \texttt{pos.x}），直接返回，避免整结构体重算。
  \item pre 在找不到历史状态时回退初始值，防止 \texttt{None} 传播。
\end{itemize}

\subsection{内存管理与资源策略}
\paragraph{依赖于 Python GC}
Ripple 运行时托管在 Python 上：对象、列表、字典由原生 GC 管理，
无自研分配器或显式释放。工程上避免泄漏的关键在于订阅关系和环检测：
\begin{itemize}
  \item 编译期消除环（\texttt{CircularDependencyDetector}），
        运行时订阅集合随节点创建/删除自动维护。
  \item 事件传播过程中仅持有局部上下文字典，完成后由 GC 回收。
\end{itemize}

\paragraph{数据驻留策略}
\texttt{GraphNode.cached\_value} 与 \texttt{state} 常驻内存；
源/流值可能是标量、列表或结构体字典。
CSV 数据加载后以二维列表缓存，避免频繁 IO。
无栈/堆手动区分，调用栈由 Python 解释器维护。

\subsection{对象模型与数据布局}
\paragraph{结构体与字段路径}
结构体类型在 AST 层为 \texttt{StructType}，运行时以 Python \texttt{dict} 存储，
字段路径（如 \texttt{line.start.x}）在解析期展开，
类型环境和触发器都以展开路径登记，使字段级订阅成为可能。

\paragraph{闭包与函数调用}
Lambda 和用户函数没有独立的"对象头"或 vtable，
而是通过"捕获环境 + 形参绑定"的上下文字典实现。
调用时复制上下文（浅拷贝）并填充形参，递归解释函数体。
无动态派发/内联缓存，简化了实现但依赖 Python 解释器的性能。

\paragraph{节点即对象}
依赖图节点自身承担"对象模型"角色：包含类型/状态/调度信息，
调度器通过节点元数据而非方法表完成执行。
Sink 节点是"无下游"的流节点，未额外引入输出缓冲区类型。

\subsection{关键技术难点与解法}
\paragraph{时序安全与环检测}
pre/fold 引入状态，若依赖图有环会导致非终止或不一致。
解决：解析期标记 stateful，编译期过滤 pre 的自引用（允许自引用但不参与环），
并用拓扑排序 + DFS 检测剩余环，发现即报错。

\paragraph{字段级依赖与触发过滤}
触发器 \texttt{on pos.x} 需精确到字段，否则会因结构体其他字段更新触发无谓重算。
解析期构造字段链，类型环境与订阅集合都用完整路径，
Engine 仅在触发依赖脏时入队目标节点。

\paragraph{类型与运行时的协同}
类型环境在编译期展开结构体字段，运行时上下文也使用同名键，可直接命中，
避免整体结构体重构或额外的投影指令；
TypeChecker 的 "\texttt{any} 回退" 保证可运行性，但同时输出警告提醒精化类型。

\paragraph{CSV 源与外部 IO}
\texttt{load\_csv} 在编译期求值并缓存，推断单元格类型（int/float/bool/字符串）；
源会登记路径与跳表头标志。为避免 IO 阻塞，CSV 解析仅在初始化或显式事件时触发。

\paragraph{CSV 文件监听与热重载}
\texttt{ripple\_watcher.py} 实现了 CSV 文件的实时监听与热重载：
\begin{itemize}
  \item \textbf{双模式检测}：优先使用 \texttt{watchdog} 库的文件系统事件，
        若不可用则回退到定时轮询（每 0.5 秒检查文件修改时间）。
  \item \textbf{防抖机制}：同一文件在 0.5 秒内的多次修改只触发一次重载，
        避免频繁的中间状态。
  \item \textbf{自动类型推断}：重载时对每个单元格重新推断类型
        （尝试 int $\rightarrow$ float $\rightarrow$ bool $\rightarrow$ string）。
  \item \textbf{事件推送}：检测到文件变更后，
        自动调用 \texttt{engine.push\_event} 更新对应源节点，触发依赖图传播。
  \item \textbf{多文件并行}：支持同时监听多个 CSV 文件，
        每个文件独立的回调函数与防抖状态。
  \item \textbf{静默运行}：默认不输出日志信息，仅在调试模式下显示文件变更通知。
\end{itemize}
使用 \texttt{load\_csv} 的源节点会在编译期自动注册到监听器，
无需手动启动监听。

\paragraph{调度公平性与性能}
当前调度为单线程、rank 优先的最简模型；
通过触发器减少入队量，状态节点缓存避免重复计算。
若未来需要并行，可在保持 rank 拓扑约束下引入工作窃取队列，
当前设计已为此预留独立的订阅集合与脏标记。

\subsection{可扩展性与演进}
\begin{itemize}
  \item \textbf{后端演进：} 若需要更高性能，
        可将"公式"从 Python 解释迁移到自定义字节码或 LLVM IR；
        现有依赖图与类型元数据可直接指导 IR 生成。
  \item \textbf{类型增强：} 在 TypeChecker 中加入代数数据类型、
        模式匹配的穷尽检查，或用合一算法替换"遇不明上下文降为 any"的策略。
  \item \textbf{调度与背压：} 可在 Engine 中加入窗口/节流/防抖的运行时原语
        （已有 map/filter/reduce/fold 基础），或为高频源引入背压协议。
  \item \textbf{调试可视化：} 结合 \texttt{ripple\_ast\_visualizer.py} 输出的 DOT，
        可进一步生成"事件时间线 + 节点值"视图，帮助教学与性能分析。
\end{itemize}

%\paragraph{小结} 本章将设计决策与源码一一对应：前端用手写 Lexer/Parser 保持可控性，类型系统在 Python 中实现分派式推断，后端直接生成“依赖图 + 公式”，运行时用拓扑驱动的图引擎保障零故障传播。尽管未采用传统 VM/IR，但依赖图模型与类型元数据为未来优化与移植奠定了清晰的接口与演化空间。